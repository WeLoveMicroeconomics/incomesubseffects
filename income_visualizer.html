<!-- File name: income_visualizer.html -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Income & Substitution Effects Visualizer</title>
<script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
<style>
body { font-family: Arial; margin: 20px; background-color: white; color: black; }
input, label { margin: 4px; color: black; }
#plot { width: 800px; height: 600px; margin-top: 20px; }
.inputs { display: flex; flex-wrap: wrap; gap: 10px; }
.inputs label { width: 180px; color: black; }
</style>
</head>
<body>
<h2>Income & Substitution Effects Visualizer</h2>

<div class="inputs">
  <label>Utility function (u(x,y)): <input id="utility" value="x^0.5*y^0.5"></label>
  <label>px (initial): <input type="number" id="px" value="1" step="0.1"></label>
  <label>px (new): <input type="number" id="px2" value="2" step="0.1"></label>
  <label>Income (m): <input type="number" id="m" value="3" step="0.1"></label>
  <button onclick="compute()">Compute & Plot</button>
</div>

<div id="plot"></div>
<div id="results"></div>

<script>
function compute() {
  const uStr = document.getElementById("utility").value.trim();
  const px = parseFloat(document.getElementById("px").value);
  const px2 = parseFloat(document.getElementById("px2").value);
  const py = 1;
  const m = parseFloat(document.getElementById("m").value);

  const isMin = uStr.replace(/\s+/g,'') === "min(x,y)";
  let A, B, C, newm;

  // Cobb-Douglas detection
  const cdMatch = uStr.match(/x\^([0-9.]+)\*y\^([0-9.]+)/);
  let cdParams = null;
  if(cdMatch) cdParams = { a: parseFloat(cdMatch[1]), b: parseFloat(cdMatch[2]) };
  let uExpr = null;
  if(!cdParams && !isMin) uExpr = math.compile(uStr);

  function cobbDouglas(px, py, m, a, b) {
    const x = (a / (a + b)) * (m / px);
    const y = (b / (a + b)) * (m / py);
    return { x, y, u: Math.pow(x,a)*Math.pow(y,b) };
  }

  function maximize(px, py, m) {
    if(cdParams) return cobbDouglas(px, py, m, cdParams.a, cdParams.b);
    if(isMin) return { x: m/(px+py), y: m/(px+py), u: m/(px+py) };
    let maxU=-Infinity, best=[0,0];
    const steps = 200;
    for(let i=0;i<=steps;i++){
      const x = (m/px)*(i/steps);
      const y = (m - px*x)/py;
      if(y<0) continue;
      let u = 0;
      try { u = uExpr.evaluate({x,y}); } catch { u = -Infinity; }
      if(u>maxU){ maxU=u; best=[x,y]; }
    }
    return { x: best[0], y: best[1], u: maxU };
  }

  // Compute A, C
  A = maximize(px, py, m);
  C = maximize(px2, py, m);

  // Compensated bundle B
  if(cdParams){
    const {a,b} = cdParams;
    // Original utility
    const uA = Math.pow(A.x,a) * Math.pow(A.y,b);
    // Compensated income
    newm = Math.pow(uA,1/(a+b)) * (a+b) * Math.pow(px2**a * py**b, 1/(a+b)) / Math.pow(a**a * b**b,1/(a+b));
    B = cobbDouglas(px2, py, newm, a, b);
  } else if(isMin){
    newm = m;
    B = {...A};
  } else {
    newm = m;
    let found=false;
    for(let z=0; z<=m*2; z+=m/100){
      let test = maximize(px2, py, z);
      if(Math.abs(test.u - A.u) < 0.01){ newm=z; found=true; break; }
    }
    B = maximize(px2, py, newm);
  }

  // Axis limits
  let maxX = Math.max(A.x,B.x,C.x,m/Math.min(px,px2))*1.1;
  let maxY = Math.max(A.y,B.y,C.y,m/py)*1.1;

  // Budget lines
  const budgetLine = (px, py, m, label, color) => ({
    x:[0,m/px], y:[m/py,0], mode:"lines", type:"scatter",
    name:label, line:{dash:"dot", color}
  });

  const plotData = [
    budgetLine(px, py, m, "Initial Budget", "blue"),
    budgetLine(px2, py, m, "New Budget", "orange"),
    budgetLine(px2, py, newm, "Compensated Budget", "green"),
    {x:[A.x], y:[A.y], mode:"markers+text", text:["A"], name:"Initial", marker:{size:10,color:"blue"}},
    {x:[B.x], y:[B.y], mode:"markers+text", text:["B"], name:"Compensated", marker:{size:10,color:"green"}},
    {x:[C.x], y:[C.y], mode:"markers+text", text:["C"], name:"Final", marker:{size:10,color:"orange"}}
  ];

  // Indifference curves
  function indiffCurve(uLevel) {
    const x=[], y=[];
    const steps=200;
    for(let i=1;i<=steps;i++){
      const xi = (maxX/steps)*i;
      let yi = null;
      if(cdParams){
        yi = Math.pow(uLevel/Math.pow(xi,cdParams.a),1/cdParams.b);
      } else if(!isMin){
        let yLow=0, yHigh=maxY;
        for(let iter=0;iter<20;iter++){
          const yMid = (yLow+yHigh)/2;
          let uVal;
          try { uVal = uExpr.evaluate({x:xi, y:yMid}); } catch { uVal=-Infinity; }
          if(uVal>uLevel) yHigh=yMid; else yLow=yMid;
          if(Math.abs(uVal-uLevel)<0.01){ yi=yMid; break; }
        }
      } else { yi = uLevel; }
      if(yi!==null && yi>0 && yi<=maxY){ x.push(xi); y.push(yi); }
    }
    return {x,y};
  }

  const icA = indiffCurve(A.u);
  const icC = indiffCurve(C.u);
  if(icA.x.length) plotData.push({x:icA.x,y:icA.y,mode:"lines",name:"Indiff Curve A",line:{color:"blue",width:1}});
  if(icC.x.length) plotData.push({x:icC.x,y:icC.y,mode:"lines",name:"Indiff Curve C",line:{color:"orange",width:1}});

  Plotly.newPlot("plot", plotData,{
    title:"Income & Substitution Effects",
    xaxis:{title:"x",range:[0,maxX],scaleratio:1,scaleanchor:"y"},
    yaxis:{title:"y",range:[0,maxY]}
  });

  const subsEff = isMin?0:(B.x-A.x);
  const incomeEff = C.x-B.x;
  const cv = (m-newm)/py;

  document.getElementById("results").innerHTML=`
    <p><b>A:</b> (${A.x.toFixed(3)}, ${A.y.toFixed(3)})<br/>
    <b>B:</b> (${B.x.toFixed(3)}, ${B.y.toFixed(3)})<br/>
    <b>C:</b> (${C.x.toFixed(3)}, ${C.y.toFixed(3)})<br/>
    <b>Substitution Effect:</b> ${subsEff.toFixed(3)}<br/>
    <b>Income Effect:</b> ${incomeEff.toFixed(3)}<br/>
    <b>Compensating Variation:</b> ${cv.toFixed(3)}</p>`;
}
</script>
</body>
</html>
