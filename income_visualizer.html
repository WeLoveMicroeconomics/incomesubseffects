<!-- File name: income_visualizer.html -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Income & Substitution Effects Visualizer</title>
<script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
<style>
body { font-family: Arial; margin: 20px; background-color: white; color: black; }
input, label { margin: 4px; color: black; }
#plot { width: 800px; height: 600px; margin-top: 20px; }
.inputs { display: flex; flex-wrap: wrap; gap: 10px; }
.inputs label { width: 180px; color: black; }
</style>
</head>
<body>
<h2>Income & Substitution Effects Visualizer</h2>

<div class="inputs">
  <label>Utility function (u(x,y)): <input id="utility" value="x^0.5*y^0.5"></label>
  <label>px (initial): <input type="number" id="px" value="1" step="0.1"></label>
  <label>px (new): <input type="number" id="px2" value="2" step="0.1"></label>
  <label>Income (m): <input type="number" id="m" value="3" step="0.1"></label>
  <button onclick="compute()">Compute & Plot</button>
</div>

<div id="plot"></div>
<div id="results"></div>

<script>
function compute() {
  const uStr = document.getElementById("utility").value.trim();
  const px = parseFloat(document.getElementById("px").value);
  const px2 = parseFloat(document.getElementById("px2").value);
  const py = 1;
  const m = parseFloat(document.getElementById("m").value);

  let A, B, C, newm;

  // Detect min-type utility
  const minMatch = uStr.match(/min\(([^,]+),([^,]+)\)/);
  let minParams = null;
  if(minMatch) {
    const left = minMatch[1].trim();
    const right = minMatch[2].trim();
    // Check if right is of form k*y
    const kMatch = right.match(/([0-9.]+)\*y/);
    if(left==='x' && kMatch) minParams = parseFloat(kMatch[1]);
  }

  // Compile smooth utilities
  let uExpr = null;
  if(!minParams) uExpr = math.compile(uStr);

  // Helper: maximize u(x,m-px*x) over x>=0
  function maximizeUtility(p, m) {
    if(minParams) {
      const k = minParams;
      const y = m / (p*k + 1);
      const x = k * y;
      return {x, y, u: Math.min(x, k*y)};
    } else {
      let maxU=-Infinity, best=[0,0];
      const steps = 500;
      for(let i=0;i<=steps;i++){
        const x = (m/p)*(i/steps);
        const y = m - p*x;
        if(y<0) continue;
        let uVal = -Infinity;
        try { uVal = uExpr.evaluate({x,y}); } catch {}
        if(uVal>maxU){ maxU=uVal; best=[x,y]; }
      }
      const [x,y] = best;
      return {x,y,u:maxU};
    }
  }

  // Compute A and C
  A = maximizeUtility(px, m);
  C = maximizeUtility(px2, m);

  // Compute compensated point B
  function findCompensated(px1, uLevel) {
    if(minParams) {
      const k = minParams;
      // Indifference curve: x = k*y or y = x/k
      // Minimize expenditure p1*x + y => minimize x*(p1 + 1/k)
      const y = uLevel / k;
      const x = k*y;
      const exp = px1*x + y;
      return {x, y, exp};
    } else {
      let bestExp=Infinity, bestX=0, bestY=0;
      const steps = 500;
      for(let i=0;i<=steps;i++){
        const x = (C.x*2)*(i/steps);
        let yCandidate = null;
        try { 
          const y0 = 0, y1 = C.y*2;
          let low = y0, high = y1;
          for(let iter=0; iter<20; iter++){
            const yMid = (low+high)/2;
            const uVal = uExpr.evaluate({x,y:yMid});
            if(uVal > uLevel) high=yMid; else low=yMid;
            if(Math.abs(uVal-uLevel)<0.01){ yCandidate=yMid; break;}
          }
        } catch {}
        if(yCandidate!==null && yCandidate>=0){
          const exp = px1*x + yCandidate;
          if(exp<bestExp){ bestExp=exp; bestX=x; bestY=yCandidate; }
        }
      }
      return {x:bestX, y:bestY, exp:bestExp};
    }
  }

  const Bdata = findCompensated(px2, A.u);
  B = {x:Bdata.x, y:Bdata.y, u:A.u};
  newm = Bdata.exp;

  // Compute substitution and income effects
  const SE = B.x - A.x;
  const IE = C.x - B.x;
  const CV = m - newm;

  // Determine plotting limits
  let maxX = Math.max(A.x,B.x,C.x)*1.2;
  let maxY = Math.max(A.y,B.y,C.y)*1.2;

  // Budget lines
  const budgetLine = (px, py, m, label, color) => ({
    x:[0,m/px], y:[m/py,0], mode:"lines", type:"scatter",
    name:label, line:{dash:"dot", color}
  });

  const plotData = [
    budgetLine(px, py, m, "Initial Budget", "blue"),
    budgetLine(px2, py, m, "New Budget", "orange"),
    budgetLine(px2, py, newm, "Compensated Budget", "green"),
    {x:[A.x], y:[A.y], mode:"markers+text", text:["A"], name:"Initial", marker:{size:10,color:"blue"}},
    {x:[B.x], y:[B.y], mode:"markers+text", text:["B"], name:"Compensated", marker:{size:10,color:"green"}},
    {x:[C.x], y:[C.y], mode:"markers+text", text:["C"], name:"Final", marker:{size:10,color:"orange"}}
  ];

  // Indifference curve generation
  function indiffCurve(uLevel) {
    const xs=[], ys=[];
    const steps=300;
    for(let i=0;i<=steps;i++){
      const x = maxX*(i/steps);
      let y=null;
      if(minParams){
        y = uLevel / minParams;
      } else {
        // Find y numerically
        let low=0, high=maxY, yCand=null;
        for(let iter=0; iter<20; iter++){
          const yMid = (low+high)/2;
          let uVal = -Infinity;
          try { uVal = uExpr.evaluate({x,y:yMid}); } catch{}
          if(uVal > uLevel) high=yMid; else low=yMid;
          if(Math.abs(uVal-uLevel)<0.01){ yCand=yMid; break;}
        }
        y = yCand;
      }
      if(y!==null && y>=0) { xs.push(x); ys.push(y); }
    }
    return {x:xs, y:ys};
  }

  const icA = indiffCurve(A.u);
  const icC = indiffCurve(C.u);
  if(icA.x.length) plotData.push({x:icA.x,y:icA.y,mode:"lines",name:"Indiff Curve A",line:{color:"blue",width:1}});
  if(icC.x.length) plotData.push({x:icC.x,y:icC.y,mode:"lines",name:"Indiff Curve C",line:{color:"orange",width:1}});

  Plotly.newPlot("plot", plotData,{
    title:"Income & Substitution Effects",
    xaxis:{title:"x", range:[0,maxX]},
    yaxis:{title:"y", range:[0,maxY]}
  });

  document.getElementById("results").innerHTML=`
    <p><b>A:</b> (${A.x.toFixed(3)}, ${A.y.toFixed(3)})<br/>
    <b>B:</b> (${B.x.toFixed(3)}, ${B.y.toFixed(3)})<br/>
    <b>C:</b> (${C.x.toFixed(3)}, ${C.y.toFixed(3)})<br/>
    <b>Substitution Effect:</b> ${SE.toFixed(3)}<br/>
    <b>Income Effect:</b> ${IE.toFixed(3)}<br/>
    <b>Compensating Variation:</b> ${CV.toFixed(3)}</p>`;
}
</script>
</body>
</html>
